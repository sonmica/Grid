<html>
  <head>    
    <style>
      body {
        margin: 0px;
      }
      .pageContainer {
        display: flex;
        flex-direction: row;
        justify-content: center;
        align-items: center;
        height: 100%;
      }
      .contentContainer {
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: 20px;
      }
      .cellContainer {
        display: flex;
        flex-direction: column;
        gap: 1px;
        background-color: lightgray;
        border: solid 1px lightgray;
      }
      .row {
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 1px;
      }
      .cell {
        width: 30px;
        height: 30px;
        background-color: white;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 24px;
        font-family: Consolas, monospace;
        cursor: default;
      }
      .cell-hover {
        background-color: lightgray;
      }
      .black {
        background-color: black;
        color: white;
      }
      .gray {
        background-color: #eee;
        color: black;
      }
    </style>

    <script>
      window.onload = (event) => {
        console.log("page is fully loaded");

        let gridContainer = document.getElementById("gridContainer");
        gridContainer.classList.add("cellContainer");
        
        //getUrl();
        const config = getConfig();
        const result = processConfig(config);
        if(!result.success) {
          console.log("Error while mapping");
          console.log(result.error);
          return;
        }

        console.log("Mapping successful");
        console.log(result.config);

        drawGrid(gridContainer, result.config);
      };

      function drawGrid(parentContainer, config) {
        const gridWidth = config.width;
        const gridHeight = config.height;

        for(let row = 0; row < gridHeight; row++) {
          const rowDiv = document.createElement("div");
          rowDiv.classList.add("row");
          parentContainer.append(rowDiv);

          for(let col = 0; col < gridWidth; col++) {
            const childNode = drawCell(mapDataToCell(config, row, col));
            rowDiv.appendChild(childNode);
          }
        }

        function drawCell({index, val, width, height}) {
          const cell = document.createElement("div");
          cell.id = index;
          cell.classList.add("cell");
          if(val !== null) {
            cell.innerText = val;
          }
          cell.setAttribute("onclick", "cycleColour(this)");
          cell.addEventListener("contextmenu", (e) => {
            e.preventDefault();
          });
          cell.addEventListener("auxclick", (e) => {
            altCycleColour(cell);
          });
          cell.onmouseover = (event) => {
            // cell.classList.add("cell-hover")
            hoverNeighboursOfId(index, width, height);
          };
          cell.onmouseout = (event) => {
            hoverNeighboursOfId(index, width, height, false);
          };
          return cell;
        }

        function mapDataToCell(config, row, col) {
          const index = row * config.width + col;
          return {
            index,
            val: config.data[index],
            width: config.width,
            height: config.height
          };
        }

        function hoverNeighboursOfId(id, width, height, hover = true) {
          const cellArray = getNeighboursOfId(id, width, height);
          console.log("cellArray", cellArray);

          const action = hover ? "add" : "remove";
          cellArray.forEach(cell => cell.classList[action]("cell-hover"));
        }

        function getNeighboursOfId(id, width, height) {
          // Raw values
          const beside = [id-1, id+1];
          const aboveBelow = [id-width, id+width]
          const diagonal = aboveBelow.map(cellId => [cellId-1, cellId+1]).flat();

          // TODO: it's cool and wonky
          

          console.log([id, ...beside, ...aboveBelow, ...diagonal]);

          const hoverColumn = getColumnById(id, width);

          return [id, ...beside, ...aboveBelow, ...diagonal]
            .filter(cellId => cellId >= 0 && cellId < width * height) // Ignore anything over the boundaries of the grid
            .filter(cellId => Math.abs(getColumnById(cellId, width) - hoverColumn) < 2) // Ignore anything that is trying to wrap around horizontally
            .map(cellId => getCellById(cellId));

          function getCellById(id) {
            return document.getElementById(id);
          }

          function getColumnById(id, width) {
            return id % width;
          }
        }
      }
    
      function getUrl() {
        const url = document.URL;
        const urlNode = document.getElementById("urlContainer");
        const urlDiv = document.createElement("div");
        urlDiv.innerText = `Page url: ${url}`;
        urlNode.appendChild(urlDiv);
      }

      function getConfig() {
        // Hardcoded config for now
        return {
          width: 15,
          height: 20,
          // Data is either
          // - a singular value
          // - or a sequence of nulls, signified by a 1-length array with the format: [sequence of nulls]
          // - or a 2-length array, with the format [value, sequence]
          data: [
            [1], 0, [2], 5, [1], 6, [2], 6, 5, [3], 4, [5], [8, 2], 9, [5], 8, [3], 5, [1], 7, [2], [8, 2], [9, 2], [2],
            9, [1], 0, 3, [1], 6, [5], 7, [2], 8, [1], 5, [1], 4, 6, [3], 2, [3], 8, 9, [3], 3, [1], 5, [1], 4, [2], 3,
            [1], 5, 6, 7, [5], 5, [1], 5, 3, [1], 3, 5, [1], [5, 2], 4, [1], 3, 4, [1], [3, 4], [2], [3, 2], [4], 3, 2,
            4, 3, 4, [2], 1, 2, [2], 3, [1], 4, [6], 3, [4, 2], [1], 2, [1], 3, [3], 4, [2], 4, [2], 4, [3, 3], 4, [1],
            4, [4], 3, [1], 2, [3], 5, [1], [4, 2], [1], 3, [3], 5, [3], 5, [1], [3, 2], 5, [1], 7, 5, [1], 1, 4, [1],
            7, 5, 6, [1], 5, [2], 5, [1], 7, [6, 2], [2], 7, [1], 7, [1], 5, [1], 3, [2], [6, 2], [7, 2], 5, [4], 5, [3],
            6, 7, 6, [3], 5, [1], [7, 2], [2], [7, 2], [1], 8, [3], 7, [4], 8, [1], 7, [1], 7, [1], 6, 8, 6, 7, [6, 2],
            [2], 5, [1], 7, [11], 0, [1], 3, [1], 3, [1], 4, [1], [4, 2], [2], 3, [1], 0
          ]
        }
      }

      function processConfig(config) {
        if(!validateDataLength(config)) {
          return {
            success: false,
            error: "Dimension and data mismatch",
            config: null
          }
        };

        return {
          success: true,
          error: null,
          config: mapData(config)
        }

        function validateDataLength(config) {
          // Returns boolean - true if width * height matches data length
          const totalLength = config.width * config.height;

          const actualLength = config.data
            .map(i => {
              // This is a singular value
              if(typeof i === "number") {
                return 1;
              }
              // This is a sequence of nulls
              if(i.length === 1) {
                return i[0];
              }
              // This is a sequence of not-nulls
              return i[1];
              // TODO: error handling?
            })
            .reduce((prev, curr) => prev += curr, 0);
          
          return totalLength === actualLength;
        }

        function mapData(config) {
          // Returns array mapping of the data object
          return {
            ...config,
            data: config.data
              .map(i => {
                // This is a singular value
                if(typeof i === "number") {
                  return i;
                }
                // Create an array of nulls, we'll flatmap it later

                // This is a sequence of nulls
                if(i.length === 1) {
                  const nullArray = new Array(i[0]).fill(null);
                  return nullArray;
                }

                // This is a sequence of values
                const valueArray = new Array(i[1]).fill(i[0]);
                return valueArray;
                // TODO: error handling?
              })
              .flat()
          }
        }
      }
    
      function cycleColour(node) {
        // cycle: none -> black -> gray
        if(node.classList.contains("black")) {
          node.classList.remove("black");
          node.classList.add("gray");
        } else if(node.classList.contains("gray")) {
          node.classList.remove("gray");
        } else {
          node.classList.add("black");
        }
      }

      function altCycleColour(node) {
        // cycle: gray -> black -> none
        if(node.classList.contains("gray")) {
          node.classList.remove("gray");
          node.classList.add("black");
        } else if(node.classList.contains("black")) {
          node.classList.remove("black");
        } else {
          node.classList.add("gray");
        }
      }
    </script>
  </head>

  <body>
    <div class="pageContainer">
      <div class="contentContainer">
        <div id="urlContainer"></div>
        <div id="gridContainer"></div>
      </div>
    </div>
  </body>
</html>